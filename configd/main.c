#include <string.h>
#include <time.h>
#include <sys/time.h>

#include <dnsinfo.h>
#include <notify.h>
#include <arpa/inet.h>

#include <TargetConditionals.h>
#include <SystemConfiguration/SCPrivate.h>
#include <SystemConfiguration/SCValidation.h>

#define VAR_RUN_RESOLV_CONF "/var/run/resolv.conf"

/* Torrekie: Grabbed from Plugins/IPMonitor/ip_plugin.c */
static __inline__ void
empty_dns()
{
    (void)unlink(VAR_RUN_RESOLV_CONF);
}

static void
set_dns(CFArrayRef val_search_domains,
	CFStringRef val_domain_name,
	CFArrayRef val_servers,
	CFArrayRef val_sortlist)
{
#ifdef DEBUG
    FILE * f = stderr;
#else
    FILE * f = fopen(VAR_RUN_RESOLV_CONF "-", "w");
#endif

    /* publish new resolv.conf */
    if (f) {
	CFIndex	i;
	CFIndex	n;

	SCPrint(TRUE, f, CFSTR("#\n"));
#if TARGET_OS_IOS
	SCPrint(TRUE, f, CFSTR("# iOS Notice\n"));
#elif TARGET_OS_TV
	SCPrint(TRUE, f, CFSTR("# tvOS Notice\n"));
#elif TARGET_OS_WATCH
	SCPrint(TRUE, f, CFSTR("# watchOS Notice\n"));
#else
	SCPrint(TRUE, f, CFSTR("# macOS Notice\n"));
#endif

	SCPrint(TRUE, f, CFSTR("#\n"));
	SCPrint(TRUE, f, CFSTR("# This file is not consulted for DNS hostname resolution, address\n"));
	SCPrint(TRUE, f, CFSTR("# resolution, or the DNS query routing mechanism used by most\n"));
	SCPrint(TRUE, f, CFSTR("# processes on this system.\n"));
	SCPrint(TRUE, f, CFSTR("#\n"));
	SCPrint(TRUE, f, CFSTR("# To view the DNS configuration used by this system, use:\n"));
	SCPrint(TRUE, f, CFSTR("#   scutil --dns\n"));
	SCPrint(TRUE, f, CFSTR("#\n"));
	SCPrint(TRUE, f, CFSTR("# SEE ALSO\n"));
	SCPrint(TRUE, f, CFSTR("#   dns-sd(1), scutil(8)\n"));
	SCPrint(TRUE, f, CFSTR("#\n"));
	SCPrint(TRUE, f, CFSTR("# This file is automatically generated.\n"));
	SCPrint(TRUE, f, CFSTR("#\n"));

	/* search xxx xxx ... */
	if (isA_CFArray(val_search_domains)) {
	    SCPrint(TRUE, f, CFSTR("search"));
	    n = CFArrayGetCount(val_search_domains);
	    for (i = 0; i < n; i++) {
		CFStringRef	domain;

		domain = CFArrayGetValueAtIndex(val_search_domains, i);
		if (isA_CFString(domain)) {
		    SCPrint(TRUE, f, CFSTR(" %@"), domain);
		}
	    }
	    SCPrint(TRUE, f, CFSTR("\n"));
	}

	/* domain xxx.xxx */
	else if (isA_CFString(val_domain_name)) {
		SCPrint(TRUE, f, CFSTR("domain %@\n"), val_domain_name);
	}

	/* nameserver xxx; nameserver xxx; ... */
	if (isA_CFArray(val_servers)) {
	    n = CFArrayGetCount(val_servers);
	    for (i = 0; i < n; i++) {
		CFStringRef	nameserver;

		nameserver = CFArrayGetValueAtIndex(val_servers, i);
		if (isA_CFString(nameserver)) {
		    SCPrint(TRUE, f, CFSTR("nameserver %@\n"), nameserver);
		}
	    }
	}

	/* sortlist xxx/xxx xxx ... */
	if (isA_CFArray(val_sortlist)) {
	    SCPrint(TRUE, f, CFSTR("sortlist"));
	    n = CFArrayGetCount(val_sortlist);
	    for (i = 0; i < n; i++) {
		CFStringRef	address;

		address = CFArrayGetValueAtIndex(val_sortlist, i);
		if (isA_CFString(address)) {
		    SCPrint(TRUE, f, CFSTR(" %@"), address);
		}
	    }
	    SCPrint(TRUE, f, CFSTR("\n"));
	}

#ifndef DEBUG
	fclose(f);
	(void)rename(VAR_RUN_RESOLV_CONF "-", VAR_RUN_RESOLV_CONF);
#endif
    }
    return;
}

static CFArrayRef
array_to_CFArray(char **array, size_t count)
{
	CFStringRef *cfstr_list = (CFStringRef *)malloc(count * sizeof(CFStringRef));

	for (size_t i = 0; i < count; i++) {
		cfstr_list[i] = CFStringCreateWithCString(kCFAllocatorDefault, array[i], kCFStringEncodingUTF8);
	}

	CFArrayRef cfarray = CFArrayCreate(NULL, (const void **)cfstr_list, count, &kCFTypeArrayCallBacks);

	for (size_t i = 0; i < count; i++) {
		CFRelease(cfstr_list[i]);
	}

	free(cfstr_list);

	return cfarray;
}

static void
write_dns(dns_config_t *dns_config)
{
	int	_sc_log_save;

	if (dns_config == NULL) {
		SCPrint(TRUE, stderr, CFSTR("No DNS configuration available\n"));
		return;
	}

	/* According to set_dns(), we only fill these 4 fields for resolv.conf */
	CFStringRef Domain = NULL;
	CFArrayRef Search = NULL, NameServer = NULL, SortList = NULL;

	/* Normally we should only have one "scoped" resolver */
        int i, j;
	for (i = 0; i < dns_config->n_scoped_resolver; i++) {
		dns_resolver_t	*resolver	= dns_config->scoped_resolver[i];

		/* search */
#ifdef DEBUG
		for (j = 0; j < resolver->n_search; j++) {
			printf("search[%d] : %s", j, resolver->search[j]);
		}
#endif
		Search = (resolver->n_search > 0) ? array_to_CFArray(resolver->search, resolver->n_search) : NULL;

		/* domain */
		if (resolver->domain != NULL) {
			Domain = CFStringCreateWithCString(kCFAllocatorDefault, resolver->domain, kCFStringEncodingUTF8);
#ifdef DEBUG
			printf("domain : %s\n", resolver->domain);
#endif
		}

		/* nameserver (max 128) */
		char **nameservers = (char **)malloc(resolver->n_nameserver * sizeof(char *));
		for (j = 0; j < resolver->n_nameserver; j++) {
			nameservers[j] = (char *)malloc(128 * sizeof(char));
			if (nameservers == NULL || nameservers[j] == NULL) {
				SCPrint(TRUE, stderr, CFSTR("Cannot allocate buffer\n"));
				abort(); /* Use abort or kill to make launchd notice the error */
			}

			_SC_sockaddr_to_string(resolver->nameserver[j], nameservers[j], 128);
#ifdef DEBUG
			printf("nameserver[%d] : %s\n", j, nameservers[j]);
#endif
		}
		NameServer = (resolver->n_nameserver > 0) ? array_to_CFArray(nameservers, resolver->n_nameserver) : NULL;

		/* sortlist */
		char **sortlists = (char **)malloc(resolver->n_sortaddr * sizeof(char *));
		for (j = 0; j < resolver->n_sortaddr; j++) {
			char abuf[32];
			char mbuf[32];
			char buf[32 + 1 + 32]; /* abuf + '/' + mbuf */

			memset(buf, 0, sizeof(buf));
			sortlists[j] = (char *)malloc((32 + 1 + 32) * sizeof(char));

			(void)inet_ntop(AF_INET, &resolver->sortaddr[j]->address, abuf, sizeof(abuf));
			(void)inet_ntop(AF_INET, &resolver->sortaddr[j]->mask,    mbuf, sizeof(mbuf));

			/* Skip writting natural netmask */
			in_addr_t a = ntohl(resolver->sortaddr[j]->address.s_addr);;
			in_addr_t m;
			if (IN_CLASSA(a)) {
				m = IN_CLASSA_NET;
			} else if (IN_CLASSB(a)) {
				m = IN_CLASSB_NET;
			} else if (IN_CLASSC(a)) {
				m = IN_CLASSC_NET;
			} else if (IN_CLASSD(a)) {
				m = IN_CLASSD_NET;
			}
			if (htonl(resolver->sortaddr[j]->mask.s_addr) != m) {
				sprintf(buf, "%s/%s", abuf, mbuf);
			} else {
				sprintf(buf, "%s", abuf);
			}
#ifdef DEBUG
			printf("sortaddr[%d] : %s/%s\n", j, abuf, mbuf);
#endif
			strncpy(sortlists[j], buf, (32 + 1 + 32));
		}
		SortList = (resolver->n_sortaddr > 0) ? array_to_CFArray(sortlists, resolver->n_sortaddr) : NULL;

		/* Everything goes correctly, delete old resolv.conf */
		empty_dns();

		/* Now, write /etc/resolv.conf */
		set_dns(Search, Domain, NameServer, SortList);
	}

	if (_sc_debug) {
		SCPrint(TRUE, stdout, CFSTR("\ngeneration = %llu\n"), dns_config->generation);
	}

	if (Search) CFRelease(Search);
	if (Domain) CFRelease(Domain);
	if (NameServer) CFRelease(NameServer);
	if (SortList) CFRelease(SortList);

	return;
}

int
main(int argc, char *argv[])
{
	dns_config_t	*dns_config;
	int		status;
	int		token;

	dns_config = dns_configuration_copy();
	write_dns(dns_config);
	if (dns_config != NULL) {
		dns_configuration_free(dns_config);
	}

	status = notify_register_dispatch(dns_configuration_notify_key(),
					  &token,
					  dispatch_get_main_queue(),
					  ^(int token){
#pragma unused(token)
						  dns_config_t		*dns_config;
						  struct tm		tm_now;
						  struct timeval	tv_now;

						  (void)gettimeofday(&tv_now, NULL);
						  (void)localtime_r(&tv_now.tv_sec, &tm_now);
#ifdef DEBUG
						  SCPrint(TRUE, stderr, CFSTR("\n*** %2d:%02d:%02d.%03d\n\n"),
							  tm_now.tm_hour,
							  tm_now.tm_min,
							  tm_now.tm_sec,
							  tv_now.tv_usec / 1000);
#endif
						  dns_config = dns_configuration_copy();
						  write_dns(dns_config);
						  if (dns_config != NULL) {
							  dns_configuration_free(dns_config);
						  }
					  });
	if (status != NOTIFY_STATUS_OK) {
		SCPrint(TRUE, stderr, CFSTR("notify_register_dispatch() failed for nwi changes, status=%u\n"), status);
		exit(1);
	}

	CFRunLoopRun();
//	dispatch_main();
	return 0;
}
